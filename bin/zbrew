#!/bin/sh
#set -x
. zbrewfuncs
setjavaenv
InvalidOption=1
TooFewParms=2
UnknownAction=3

#
# Temporary hack - replace with a proper message file
#
msg() {
	pgm=$1
	msgnum=$2
	msgtype=$3
	
	shift 3
	args=$*

	case ${msgnum} in 
		${InvalidOption}) msgtext="Invalid option specified: -";;
		${TooFewParms}) msgtext="Too few Parameters specified. Expected 2 but received: ";;
		${UnknownAction}) msgtext="Unknown action specified: ";;
		*) msgtext="Internal Error. Unknow msgnum: ${msgnum}";;
	esac
	echo "ZCL000"${msgnum}${msgtype} "${msgtext}${args}" >&2
}

#
# Temporary hack - replace with a manpage
#
syntax() {
	echo "\
zbrew [-cvdr] search|order|smpreceiveptf|install|update|receivezos|configure|uninstall <software>
	and <software> is the software to search for
	(Note that install invokes several functions which are: ${install_verbs})
	-c: clean files before processing (e.g. delete SMP/E CSI datasets) and clean temporary files after processing (e.g. SMPNTS directory)
	-r function_name install: restart install at specific function (function_name must be one of: ${install_verbs})
	
Note:
	zbrew has a properties file called zbrew.properties. The following properties need to be specified:
		ZBREW_ORDERROOT: 	The writable directory root where ORDER information will be placed by SMP/E (currently this needs to be done manually)
					Each product you ORDER will have a corresponding order file called <software>.order
		ZBREW_PROPSROOT: 	The writable directory root where custom properties for a product can be specified. 
					Each product you customize can have an optional <software>custominst.properties and/or <software>customconfig.properties file
	If any installation customization is required, edit the <software>custominstall.properties before you INSTALL.   
	If any configuration customization is required, edit the <software>customconfig.properties file after you INSTALL <software> but before you CONFIGURE.   

Here is a sample order file for COBOL 6.3.0 you would create at ${ZBREW_ORDERROOT}/igy630.order

SMPE_DELIVERY=SHOPZ
SMPE_FTPHOST=deliverycb-mul.dhe.ibm.com
SMPE_FTPFILE=2019110150147/PROD/GIMPAF.XML
SMPE_FTPUSER=AUserFromShopZ
SMPE_FTPPW=APasswordFromShopZ
SMPE_FTPHASH=AHashValueFromShopZ
SMPE_FTPID=AnIDFromShopZ
	    
zbrew Examples:
	zbrew search cobol     <-- search for products with COBOL in their description
	zbrew order igy630     <-- submit an order for IGY630J software (receive can not be performed until complete)
	zbrew install igy630   <-- check that all pre-reqs required for COBOL are satisfied, then SMP/E RECEIVE the product, then run IGY630-specific install steps, then SMP/E APPLY the product
	zbrew -c -v install igy630   <-- do uninstall and verbose install
	zbrew -r smpconfig install igy630   <-- restart install at the smpconfig step
	zbrew update igy630 <-- apply all PTFs currently in receive status 
	zbrew uninstall igy630 <-- remove all SMP/E datasets and product-specific datasets
	zbrew configure igy630 <-- run product-specific configuration after SMP/E APPLY step
	zbrew smpreceiveptf igy630 zos.file.name <-- receive a PTF from a z/OS sequential or PDS file
" >&2 
	exit 16
}

#
# Temporary hack - replace with call to IBM-managed server (ShopZ) to get proper list
#
search() {
	zbrewlog "search" $*
	search=$1
	callerdir=`callerdir $0`
	grep -i "${search}" ${callerdir}/../zbrew.software
	zbrewlog "search RC: ${rc}"
	return 0
}

#
opts=$*
# Temporary hack - replace with proper RESTful call to ShopZ to submit request
# Response will be an ORDER number that, when complete, will have information needed  
# for the RECEIVE
#
order() {
	zbrewlog "order" $*
	# currently no-op. ORDER directory for COBOL IGY630E pre-populated
	if [ ${verbose} -gt 0 ]; then
		echo "order $1" >&2
	fi
	zbrewlog "order RC: ${rc}"
	return 0
}



receive() {
       	props="${ZBREW_ORDERROOT}/${ussname}order.json"
       	zbrewpropse "${ussname}" order "${props}"

	if [ ${verbose} -gt 0 ]; then
		echo "Performing SMP/E Receive $*" >&2
	fi
	case ${SMPE_DELIVERY} in
		SHOPZ)
			zbrewlog "Receiving from ShopZ for: "${sw}
			out=`smpfromshopz ${opts} ${sw}`
			;;
		PPA)
			zbrewlog "Receiving from PPA for: "${sw}
			out=`smpfromppa ${opts} ${sw}`
			;;
		LOCAL)
			zbrewlog "Receiving from LOCAL NTS for: "${sw}
			out=`smpfromnts ${opts} ${sw}`
			;;
		*)
			echo "SMPE_DELIVERY must be one of SHOPZ, PPA, LOCAL and must be specified in your ORDER file" >&2
			;;
	esac
	return $?
}

#
# Temporary hack - need a better way to locate where pre-req script is
#

prodreq() {
	zbrewlog "prodreq" $*
	
	tmp_frspace=$(df -k ${ZBREW_TMP} | tail -1 | awk '{print $3}' | awk -F'/' '{print $1}')
	if [ "${tmp_frspace}" -lt '307200' ]; then
		echo "Warning, ${ZBREW_TMP} is low on free space, it is recommended to have at least 300 MB available"
		echo "Current free space available is: ${tmp_frspace} KB"
		return 16
	fi
        
	ussname=$(echo ${sw} | tr '[:upper:]' '[:lower:]');
	prefix=`echo ${ussname} | awk '{print substr($0,0,3)}'`
	if [ ${verbose} -gt 0 ]; then
		echo "Checking requisites ${opts} ${sw}" >&2
	fi
	SWDIR="${mydir}/../../zbrew-${prefix}/${ussname}/"
	json="${SWDIR}${ussname}req.json"
	if [ -f "${json}" ]; then
		smpchkreq ${opts} ${ussname} ${json}
		return $?
	else
		echo "Unable to find product requisite JSON file: ${json}. Installation failed."
		return 16
	fi
}




update() {
	export ALLPTFS=1
	for zbrewfunc in ${update_verbs}; do
		runfunc="${zbrewfunc}"
                if [ "${runfunc}" = "smpapplycheck" ]; then
                        opts="$opts -p"
                        runfunc="smpappacc"
                fi
                if [ "${runfunc}" = "smpapply" ]; then
                        opts="$opts -q"
                        runfunc="smpappacc"
                fi
                out=`${runfunc} ${opts} ${sw}`
                rc=$?
		zbrewlog "${runfunc} ${opts}" $*
                zbrewlog "${runfunc} RC: ${rc}"
                if [ "$rc" -gt 0 ] || [ "$verbose" -gt 0 ]; then
                        echo "${out}" >&2
                fi
                if [ "$rc" -gt 0 ]; then
                        return $rc
                fi
        done
        return $rc
	unset ALLPTFS	
}



install() {
	export ALLPTFS=0
	zbrewlog "install" $*
	for zbrewfunc in ${install_verbs}; do
		runfunc="${zbrewfunc}"
		if [ "${runfunc}" = "smpapplycheck" ]; then
			opts="$opts -p"
			runfunc="smpappacc"
		fi
		if [ "${runfunc}" = "smpapply" ]; then
			opts="$opts -q"
                        runfunc="smpappacc"
		fi
                if [ "${runfunc}" = "smpacceptcheck" ]; then
			opts="$opts -r"
                        runfunc="smpappacc"
                fi
                if [ "${runfunc}" = "smpaccept" ]; then
			opts="$opts -s"
                        runfunc="smpappacc"
                fi

		if [ "${restart}" != "NORESTART" ]; then
			if [ "${zbrewfunc}" != "${restart}" ]; then
				continue
			else
				restart="NORESTART"
			fi
		fi
		out=`${runfunc} ${opts} ${sw}`
		rc=$?
		zbrewlog "${runfunc} RC: ${rc}"
		if [ "$rc" -gt 0 ] || [ "$verbose" -gt 0 ]; then
			echo "${out}" >&2
		fi
		if [ "$rc" -gt 0 ]; then
			return $rc
		fi
	done	
	return $rc
}

#
# Temporary hack - need a better way to locate where installation script is
#
configure() {
	zbrewlog "smpconfig" $*

        ussname=$(echo ${sw} | tr '[:upper:]' '[:lower:]');
	prefix=`echo ${ussname} | awk '{print substr($0,0,3)}'`
        if [ ${verbose} -gt 0 ]; then
	        echo "configure ${opts} ${sw}" >&2
	fi
	prodconfig="${mydir}/../../zbrew-${prefix}/${ussname}/${ussname}config"
        if [ -f "${prodconfig}" ]; then
     	        ${prodconfig} ${opts}
		zbrewlog "smpconfigure RC: $?"
		return $?
        else                            
		echo "Unable to find product configuration program: ${prodconfig}. Installation failed."
                return 16               
	fi
}

install_verbs="prodreq smpconfig receive smpcrdddef proddsalloc smpapplycheck smpapply smpacceptcheck smpaccept"
update_verbs="smpapplycheck smpapply"

debug=0
verbose=0
clean=0
restart="NORESTART"
opts=""
while getopts ":cvdr:" opt; do
  case ${opt} in
    d )
      debug=1
      opts="${opts} -d"
      ;;
    r )
      restart=${OPTARG}
      rescheck='notok'
      for testarg in ${install_verbs}; do
	if [ "${restart}" = "${testarg}" ]; then
		rescheck='ok'
		break
        fi
      done
      if [ "${rescheck}" = 'notok' ]; then
      	msg zbrew ${InvalidOption} E "${OPTARG}"
	exit 4
      fi
      ;;
    c )
      clean=1
      opts="${opts} -c"
      ;;
    v )
      verbose=1
      opts="${opts} -v"
      ;;
    \?)
      if [ ${OPTARG} != "?" ]; then
	msg zbrew ${InvalidOption} E "${OPTARG}"
      fi
      syntax
      exit 4
      ;;
  esac
done
shift $(expr $OPTIND - 1 )
if [ $# -lt 2 ]; then
	msg zbrew ${TooFewParms} E "$#"
	syntax
	exit 16
fi

mydir=$(callerdir ${0})
props="${mydir}/../properties/zbrewprops.json"
zbrewpropse zbrew config "${props}"
sw=$2
ussname=$(echo ${sw} | tr '[:upper:]' '[:lower:]');
zosname=$(echo ${sw} | tr '[:lower:]' '[:upper:]');
zosfile=$(echo ${3} | tr '[:lower:]' '[:upper:]');

verb=$1

case ${verb} in
	search ) 
		out=`search $2`  
		rc=$?  
		echo "${out}" | tr '_' ' '
		;;
	order ) 
		out=`order ${opts} $2`  
		rc=$?  
		echo "${out}"
		;;
	smpconfig )
		if [ ${verbose} -gt 0 ]; then
			echo "Allocate SMP/E datasets for $2 " >&2
		fi
		out=`smpconfig ${opts} ${sw}`
		rc=$?
		if [ $rc -gt 0 ]; then
			echo "Unable to configure SMP/E datasets." >&2
			echo "${out}" >&2
			exit $rc
		fi
		;;
	smpreceive )
		out=`receive ${opts} ${sw}`; 
		rc=$? 
		if [ $rc -gt 0 ]; then
			echo "${out}"
			exit $rc
		fi
		;;
        smpreceiveptf )
                out=`smpfromfile ${opts} ${sw} ${zosfile}`;
                rc=$?
                if [ $rc -gt 0 ]; then
                        echo "${out}"
                        exit $rc
                fi
                ;;
	prodreq )
		out=`prodreq ${opts} ${sw}`

		rc=$?
		if [ $verbose -gt 0 ]; then
			echo ${out}
		fi 
		if [ $rc -gt 0 ]; then
			echo "${out}" 
			exit $rc
		fi
		;;
	smpcrdddef )
		out=`smpcrdddef ${opts} ${sw}`
		rc=$?
		if [ $rc -gt 0 ]; then
                        echo "${out}"
                        exit $rc
                fi
                ;;
	proddsalloc )
		out=`proddsalloc ${opts} ${sw}`
		rc=$?
		if [ $rc -gt 0 ]; then
			echo "${out}"
			exit $rc
		fi
		;;
	smpapplycheck )
		opts="${opts} -p"
		out=`smpappacc ${opts} ${sw}`
		rc=$?
		if [ $rc -gt 0 ] || [ $verbose -gt 0 ]; then
                        echo "${out}"
                        exit $rc
                fi
                ;;
	smpapply )
		opts="${opts} -q"
		out=`smpappacc ${opts} ${sw}`
		rc=$? 
		if [ $rc -gt 0 ] || [ $verbose -gt 0 ]; then
			echo "${out}" 
			exit $rc
		fi
		;;
        smpacceptcheck )
		opts="${opts} -r"
                out=`smpappacc ${opts} ${sw}`
                rc=$?
                if [ $rc -gt 0 ] || [ $verbose -gt 0 ]; then
                        echo "${out}"
                        exit $rc
                fi
                ;;
        smpaccept )
		opts="${opts} -s"
                out=`smpappacc ${opts} ${sw}`;
                rc=$?
                if [ $rc -gt 0 ] || [ $verbose -gt 0 ]; then
                        echo "${out}"
                        exit $rc
                fi
                ;;
	install )
		out=`install ${opts} ${sw}`
		rc=$? 
		if [ $rc -gt 0 ] || [ $verbose -gt 0 ]; then
			echo "${out}" 
			exit $rc
		fi
		;;
        update  )
		opts="${opts} -t"
                out=`update ${opts} ${sw}`
                rc=$?
                if [ $rc -gt 0 ] || [ $verbose -gt 0 ]; then
                        echo "${out}"
                        exit $rc
                fi
                ;;
	configure ) 
		out=`configure ${opts} ${sw}`
		rc=$?
		if [ $rc -gt 0 ]; then
			echo "${out}" 
		fi
		;;	
	uninstall ) 
		out=`prodclean ${opts} ${sw}`
		rc=$?
		zbrewlog "Uninstall ${sw} Return Code: ${rc}"
		if [ "${verbose}" = "1" ]; then
			echo "Uninstall completed: ${rc}"
		fi
                if [ $rc -gt 0 ]; then
                        echo "${out}"
                fi
		
		;;	
	* ) msg zbrew ${UnknownAction} E ${verb}; exit 16;;
esac

exit $rc
