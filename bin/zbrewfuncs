callerdir() {
	calledas="$1"
	calledasdir="$(dirname ${calledas})"
	if [ "${calledasdir}" = '.' ]; then
		if [ "${calledas%%/*}" = "${calledas}" ]; then
			calledasdir=''
		fi
	fi
	if [ "${calledasdir}" = '' ]; then
		calledasdir=$(abspath "${calledas}")
	fi
	echo "${calledasdir}"
}

setjavaenv() {
	if [ -z "${SMPE_JAVAHOME}" ]; then
		if [ -z "${JAVA_HOME}" ]; then
			javaloc=`whence java 2>/dev/null`
			if [ $? -eq 0 ]; then
	                        export SMPE_JAVAHOME="$(dirname ${javaloc})/../"
			else
	                    	echo "Unable to set SMPE_JAVAHOME. Please export SMPE_JAVAHOME before running"
	                        exit 16
			fi
		else
	            	export SMPE_JAVAHOME="${JAVA_HOME}"
		fi
	fi
	if [ -z "${SMPE_CLASSPATH}" ]; then
		if [ -d /usr/lpp/smp/classes ]; then
			export SMPE_CLASSPATH="/usr/lpp/smp/classes"
		else
	            	echo "Unable to set SMPE_CLASSPATH. Please export SMPE_CLASSPATH before running"
			exit 16
		fi
	fi
	if ! [ -d ${SMPE_JAVAHOME} ]; then
	    	echo "SMPE_JAVAHOME environment variable is defined to ${SMPE_JAVAHOME} but the directory does not exist. Please create directory or change environment variable."
		exit 16
	fi
	
	if ! [ -d ${SMPE_CLASSPATH} ]; then
	    	echo "SMPE_CLASSPATH environment variable is defined to ${SMPE_JAVAHOME} but the directory does not exist. Please create directory or change environment variable."
		exit 16
	fi
	
}

zbrewlog() {
	log_dir="${ZBREW_TMP}/zbrewlog"
	log_msg=$*
	log_time=$(date -u)
	echo "${log_time} ${log_msg}" >> ${log_dir}
}	

zbrewtest() {
	lmsg="$1"
	lexpected="$2"
	lactual="$3"

	if [ "${lexpected}" != "${lactual}" ]; then
		echo "Test Failed. ${lmsg}" >&2
		echo "Expected: ${lexpected}" >&2
		echo "Actual: ${lactual}" >&2
		exit 16
	fi	
}

zbrewprops() {
	if [ $# -lt 3 ]; then
		echo "Syntax: zbrewprops <swname> <category> [<file>]+" >&2
		echo "where:" >&2
		echo "  <swname> is the software these properties are associated with" >&2
		echo "  <category> is the software category these properties are associated with" >&2
		echo "  <file> is a JSON properties file" >&2
		echo "Each key/value pair will be evaluated, creating a variable <key> with a value <value>" >&2
		return 16
	fi
	swname=$1
	shift 1
	category=$1
	shift 1
	for props in $*; do
		if [ -f "${props}" ]; then
			props=`readprops ${swname} ${category} <${props}`
			OLDIFS=$IFS; IFS="
		"
			line=0
			for p in $props; do
				line=$(($line+1))
				p=`echo "$p" | awk '!/#/ { print $0; }'`
				if [ "$p" != '' ]; then
					key="${p%%=*}"
					if [ "${key}" = "${p}" ]; then
						echo "The line ${p} does not have a valid key/value pair of the form <key>=<value>. Line ignored." >&2
					else
						# Evaluate the line in a child shell. If it has errors, report them, otherwise repeat
						(eval "$p" 2>/dev/null >/dev/null)
						if [ $? -gt 0 ]; then
							echo "The key/value pair '$p' could not be evaluated. Please correct line ${line}" >&2
							return 16
						fi
						val="${p#*=}"

						# Set the key only if it has not already been set
						cmd="${key}=\${${key}-${val}}" 
						eval "export ${cmd}"
					fi
				fi
			done
			IFS=$OLDIFS
		else
			echo "Unable to find properties file ${props}" >&2
			return 16
		fi
		if [ ${line} -eq 0 ]; then
			echo "No properties were read for swname: ${swname}, category: ${category}, file:${props}." >&2
			return 8
		fi
	done

	return 0
}

zbrewpropse() {
	zbrewprops $*
	if [ $? -gt 0 ]; then
		exit 4
	fi
	return 0
}

zbrewswinstalled() {
	sw=$(echo $1 | tr '[:lower:]' '[:upper:]');

	if [ "${sw}" = "" ]; then
		echo "zbrewswinstalled: Error - need to specify the software to check" >&2
		return 0
	fi
	csi="ZBREW_${sw}HLQ"
	eval "value=\${$csi}"
	if [ "${value}" = "" ] || [ "${value}" = "NONE" ]; then
		return 0
	fi
	return 1
}

issueTSO() {
	cmd=$1
	tmpout="${ZBREW_TMP}/$$tso.out"
	tsocmd "${cmd}" >$tmpout 2>/dev/null
	rc=$?
	if [ $rc -gt 0 ]; then
		cat "${tmpout}" >&2
	fi
	rm -f "${tmpout}"
	return $rc
}

chk() {
	rc=$1
	msg="$2"

	if  [ $rc -eq 0 ]; then
		return 0
	fi
	echo "${msg}" >&2
	exit $rc
}

isinteger() {
	val=$1
	result=`echo "$1" | tr -d '[:digit:]'`
	if [ "${result}" = '' ] ; then 
		echo true
	else
		echo false
	fi
}

undefinedProperty() {
	val=$1
	if [ "${val}" = "" ] || [ "${val}" = "NONE" ]; then
		echo true
	else
		echo false
	fi
}
definedProperty() {
	negate=`undefinedProperty "$1"`
	if ${negate}; then
		echo false;
	else
		echo true
	fi
}

racfGroupExists() {
	tsocmd "LISTGRP $1" >/dev/null 2>/dev/null
	if [ $? -eq 0 ]; then
		echo true
	else
		echo false
	fi
}

racfProfileExists() {
	tsocmd "RLIST "$1" "$2"" >/dev/null 2>/dev/null
	if [ $? -eq 0 ]; then
		echo true
	else
		echo false
	fi
}

racfUserExists() {
	user="$1"
	tsocmd "listuser ${user}" >/dev/null 2>&1
	if [ $? -gt 0 ]; then
		echo false
	else
		echo true
	fi
}

racfPermitUsers() {
	class="$1"
	profile="$2"
	access="$3"
	shift 3
	users="$*"

	if `undefinedProperty "${users}"`; then
		return 0
	fi

	for user in $users; do
		if `racfUserExists "${user}"` ; then
			tsocmd "PERMIT ${profile} CLASS(${class}) DELETE ID(${user})" >/dev/null 2>/dev/null
			issueTSO "PERMIT ${profile} CLASS(${class}) ACCESS(${access}) ID(${user})"
			chk "$?" "Unable to permit ${profile} class(${class}) access(${access}) id(${user})"
		fi
	done
	return 0
}

racfActivateAndShareClasses() {
	classes="$*"

	for class in $classes; do
		issueTSO "SETROPTS CLASSACT(${class}) RACLIST(${class})"
		chk "$?" "Unable to activate and share ${class}"
	done
	return 0
}

racfSetGenericClasses() {
	classes="$*"

	for class in $classes; do
		issueTSO "SETROPTS GENERIC(${class})"
		chk "$?" "Unable to set class ${class} as generic"
	done
	return 0
}

racfRefreshClasses() {
	classes="$*"

	for class in $classes; do
		issueTSO "SETROPTS RACLIST(${class}) REFRESH"
		chk "$?" "Unable to refresh class ${class}"
	done
	return 0
}

racfSubjectsDN() {
	commonName="$1"
	tv="${ZBREW_X509DN_T}"	
	ouv="${ZBREW_X509DN_OU}"	
	ov="${ZBREW_X509DN_O}"	
	lv="${ZBREW_X509DN_L}"	
	spv="${ZBREW_X509DN_SP}"	
	cv="${ZBREW_X509DN_C}"	

	subjectsDN="SUBJECTSDN(CN('${commonName}')"
	if `definedProperty "${tv}"`; then
		subjectsDN="${subjectsDN} T('${tv}')"
	fi
	if `definedProperty "${ouv}"`; then
		subjectsDN="${subjectsDN} OU('${ouv}')"
	fi
	if `definedProperty "${ov}"`; then
		subjectsDN="${subjectsDN} O('${ov}')"
	fi
	if `definedProperty "${lv}"`; then
		subjectsDN="${subjectsDN} L('${lv}')"
	fi
	if `definedProperty "${spv}"`; then
		subjectsDN="${subjectsDN} SP('${spv}')"
	fi
	if `definedProperty "${cv}"`; then
		subjectsDN="${subjectsDN} C('${cv}')"
	fi
	subjectsDN="${subjectsDN})"
	echo "${subjectsDN}"
	return 0
}

jclAddDatasetToDD() {
	step="$1"
	dd="$2"
	dataset="$3"
	jcl="$4"

#
# Extract the contents of the STEP ${step} into stepText 
#
	start=`echo "${jcl}" | awk -vstep=$step ' /\/\/[A-Z0-9]+[ ]+EXEC / { if (substr($1,3) == step) { print NR; exit 0 }}'`
	rest=`echo "${jcl}" | tail +${start}`
	end=`echo "${rest}" | tail +2 | awk ' /\/\/[A-Z0-9]+[ ]+EXEC / { print NR; exit 0 }'`

	if [ "${end}" = '' ]; then
		end=`echo "${rest}" | wc -l`
	fi

	stepText=`echo "${rest}" | head -n ${end}`

#
# Extract the DDName from the step
#
	start=`echo "${stepText}" | awk -vdd=$dd ' /\/\/[A-Z0-9]+[ ]+/ { if (substr($1,3) == dd) { print NR; exit 0 }}'`
	rest=`echo "${stepText}" | tail +${start}`
	end=`echo "${rest}" | tail +2 | awk ' /\/\/[A-Z0-9]+[ ]+/ { print NR; exit 0 }'`

	if [ "${end}" = '' ]; then
		end=`echo "${rest}" | wc -l`
	fi

	ddText=`echo "${rest}" | head -n ${end}`

#
# Add the new dataset to the TOP of the DDName concatenation
# MSF - make this prettier by putting the right number of spaces after the //
#
	ddlen=`echo -n "//$dd " | wc -c | xargs echo`
	secondLineDDText=`echo "${rest}" | head -1 | cut -c ${ddlen}-80`
	echo "//${dd} ${dataset},DISP=SHR"
	echo "// ${secondLineDDText}"
	echo "${ddText}" | tail +2
	return 0
}
